<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>金银岛</title><link>http://blog.atttx123.cn/</link><description>Recent content on 金银岛</description><generator>Hugo -- gohugo.io</generator><atom:link href="http://blog.atttx123.cn/index.xml" rel="self" type="application/rss+xml"/><item><title>深入浅出正则表达式</title><link>http://blog.atttx123.cn/posts/head-first-regular-expression/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://blog.atttx123.cn/posts/head-first-regular-expression/</guid><description>本文是Jan Goyvaerts为RegexBuddy写的教程的译文
###* 什么是正则表达式
基本说来，正则表达式是一种用来描述一定数量文本的模式。Regex代表Regular Express。本文将用regex来表示一段具体的正则表达式。一段文本就是最基本的模式，简单的匹配相同的文本。
###* 不同的正则表达式引擎
正则表达式引擎是一种可以处理正则表达式的软件。通常，引擎是更大的应用程序的一部分。在软件世界，不同的正则表达式并不互相兼容。本教程会集中讨论Perl 5 类型的引擎，因为这种引擎是应用最广泛的引擎。同时我们也会提到一些和其他引擎的区别。许多近代的引擎都很类似，但不完全一样。例如.NET正则库，JDK正则包。
###* 文字符号
最基本的正则表达式由单个文字符号组成。如a，它将匹配字符串中第一次出现的字符“a”。如对字符串“Jack is a boy”。“J”后的“a”将被匹配。而第二个“a”将不会被匹配。 正则表达式也可以匹配第二个“a”，这必须是你告诉正则表达式引擎从第一次匹配的地方开始搜索。在文本编辑器中，你可以使用“查找下一个”。在编程语言中，会有一个函数可以使你从前一次匹配的位置开始继续向后搜索。
类似的，cat会匹配“About cats and dogs”中的“cat”。这等于是告诉正则表达式引擎，找到一个c，紧跟一个a，再跟一个t。
要注意，正则表达式引擎缺省是大小写敏感的。除非你告诉引擎忽略大小写，否则cat不会匹配“Cat”。
特殊字符 对于文字字符，有11个字符被保留作特殊用途。他们是：
[ ] \ ^ $ . | ? * + ( ) 这些特殊字符也被称作元字符。
如果你想在正则表达式中将这些字符用作文本字符，你需要用反斜杠“\”对其进行换码 (escape)。例如你想匹配“1+1=2”，正确的表达式为1+1=2.
需要注意的是，1+1=2也是有效的正则表达式。但它不会匹配“1+1=2”，而会匹配“123+111=234”中的“111=2”。因为“+”在这里表示特殊含义（重复1次到多次）
在编程语言中，要注意，一些特殊的字符会先被编译器处理，然后再传递给正则引擎。因此正则表达式1+2=2在C++中要写成“1\+1=2”。为了匹配“C:\temp”，你要用正则表达式C:\temp。而在C++中，正则表达式则变成了“C:\\temp”。
不可显示字符 可以使用特殊字符序列来代表某些不可显示字符：
&amp;lt;code class=&amp;quot;code&amp;quot;&amp;gt;\t&amp;lt;/code&amp;gt;代表Tab(0x09) &amp;lt;code class=&amp;quot;code&amp;quot;&amp;gt;\r&amp;lt;/code&amp;gt;代表回车符(0x0D) &amp;lt;code class=&amp;quot;code&amp;quot;&amp;gt;\n&amp;lt;/code&amp;gt;代表换行符(0x0A) 要注意的是Windows中文本文件使用“\r\n”来结束一行而Unix使用“\n”
###* 正则表达式引擎的内部工作机制
知道正则表达式引擎是如何工作的有助于你很快理解为何某个正则表达式不像你期望的那样工作。
有两种类型的引擎：文本导向(text-directed)的引擎和正则导向(regex-directed)的引擎。Jeffrey Friedl把他们称作DFA和NFA引擎。本文谈到的是正则导向的引擎。这是因为一些非常有用的特性，如“惰性”量词(lazy quantifiers)和反向引用(backreferences)，只能在正则导向的引擎中实现。所以毫不意外这种引擎是目前最流行的引擎。
你可以轻易分辨出所使用的引擎是文本导向还是正则导向。如果反向引用或“惰性”量词被实现，则可以肯定你使用的引擎是正则导向的。你可以作如下测试：将正则表达式regex|regex not应用到字符串“regex not”。如果匹配的结果是regex，则引擎是正则导向的。如果结果是regex not，则是文本导向的。因为正则导向的引擎是“猴急”的，它会很急切的进行表功，报告它找到的第一个匹配 。
正则导向的引擎总是返回最左边的匹配 这是需要你理解的很重要的一点：即使以后有可能发现一个“更好”的匹配，正则导向的引擎也总是返回最左边的匹配。
当把cat应用到“He captured a catfish for his cat”，引擎先比较c和“H”，结果失败了。于是引擎再比较c和“e”，也失败了。直到第四个字符，c匹配了“c”。a匹配了第五个字符。到第六个字符t没能匹配“p”，也失败了。引擎再继续从第五个字符重新检查匹配性。直到第十五个字符开始，cat匹配上了“catfish”中的“cat”，正则表达式引擎急切的返回第一个匹配的结果，而不会再继续查找是否有其他更好的匹配。</description></item></channel></rss>